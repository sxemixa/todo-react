## Хуки
### useState
Что делает: позволяет хранить и обновлять состояние в функциональном компоненте.</br>
Как использовать:</br>
```const [state, setState] = useState(initialValue);```

### useEffect
Что делает: позволяет выполнять побочные эффекты в функциональных компонентах, такие как работа с асинхронными операциями,</br> API-запросами, подписками и взаимодействиями с браузером.</br>
Как использовать:</br>
```javascript
useEffect(() => {
  
код, который выполнится при монтировании и обновлении компонента
  return () => {
    
код, который выполнится при размонтировании (например, очистка ресурсов)
  };
}, [dependencies]); массив зависимостей
```
###  useContext
Что делает: позволяет использовать данные из контекста (например, тему, язык) в любом компоненте без необходимости прокидывать их через пропсы.</br>
Как использовать:</br>
```javascript
const value = useContext(MyContext);
MyContext — объект контекста, который был создан с помощью React.createContext().
```
### useReducer
Что делает: позволяет управлять сложным состоянием с использованием редюсера. Это полезно, когда состояние зависит от нескольких значений или действий.</br>
Как использовать:</br>
```javascript
const [state, dispatch] = useReducer(reducer, initialState);
reducer — это функция, которая описывает, как изменяется состояние в ответ на действия (аналогично Redux).
dispatch — функция, с помощью которой вы можете отправлять действия для изменения состояния.
```
###  useRef
Что делает: предоставляет возможность создать ссылку на DOM-элемент или сохранять данные между рендерами компонента без вызова перерисовки.</br>
Как использовать:</br>
```javascript
const myRef = useRef(initialValue);
myRef — объект с полем current, который содержит значение, на которое ссылается.
Это полезно для доступа к DOM-элементам напрямую или хранения промежуточных данных.
```
###  useMemo
Что делает: мемоизирует значение, чтобы избежать его повторного вычисления при каждом рендере, если зависимости не изменились.</br>
Как использовать:</br>
```javascript
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
Функция computeExpensiveValue будет вызываться только тогда, когда изменяются зависимости [a, b].
```
### useCallback
Что делает: мемоизирует функцию, чтобы её не пересоздавать при каждом рендере, если зависимости не изменились.</br>
Как использовать:</br>
```javascript
const memoizedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```
### useLayoutEffect
Что делает: похож на useEffect, но вызывается синхронно после всех изменений в DOM. Полезен для операций, которые нужно выполнить до отображения изменений на экране (например, измерения DOM-элементов).</br>
Как использовать:</br>
```javascript
useLayoutEffect(() => {
  
код, который выполнится синхронно после обновления DOM
}, [dependencies]);
```
### useImperativeHandle
Что делает: позволяет управлять тем, какие методы и свойства компонента будут доступны извне при использовании ref.</br>
Как использовать:</br>
```javascript
useImperativeHandle(ref, () => ({
  someMethod() {
    
код, доступный извне
  }
}));
```
### useDebugValue
Что делает: добавляет метку для отображения значения в React DevTools. Обычно используется в пользовательских хуках.</br>
Как использовать:</br>

```useDebugValue(value);```